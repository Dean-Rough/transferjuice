/**
 * Dynamic Polaroid Frame Generator
 * Creates polaroid-style frames with handwritten text using Wikipedia images
 */

import sharp from "sharp";
import { createCanvas, loadImage, registerFont } from "canvas";
import { promises as fs } from "fs";
import path from "path";
import { findPlayerImage, getFallbackImage } from "./wikipediaService";

export interface FrameOptions {
  style: "polaroid" | "trading-card";
  maxWidth: number;
  maxHeight: number;
  borderPercent: {
    top: number;
    left: number;
    right: number;
    bottom: number;
  };
  textOptions: {
    fontFamily: string;
    fontSize: number;
    color: string;
    position: "bottom-center" | "bottom-left" | "bottom-right";
  };
  rotation: number; // degrees
}

export interface GeneratedFrame {
  url: string;
  localPath: string;
  width: number;
  height: number;
  playerName: string;
  cached: boolean;
  source: "wikipedia" | "fallback";
}

export class PolaroidFrameGenerator {
  private static readonly CACHE_DIR = path.join(
    process.cwd(),
    "public",
    "generated-frames",
  );
  private static readonly FONT_PATH = path.join(
    process.cwd(),
    "public",
    "fonts",
    "Diary-Notes.otf",
  );
  private static fontRegistered = false;

  private static readonly DEFAULT_OPTIONS: FrameOptions = {
    style: "polaroid",
    maxWidth: 300,
    maxHeight: 400,
    borderPercent: {
      top: 5,
      left: 5,
      right: 5,
      bottom: 20, // Extra space for handwritten text
    },
    textOptions: {
      fontFamily: "Diary-Notes",
      fontSize: 16,
      color: "#2c2c2c",
      position: "bottom-center",
    },
    rotation: 0, // Will be set randomly
  };

  /**
   * Generate a polaroid frame for a player
   */
  static async generatePlayerFrame(
    playerName: string,
    options: Partial<FrameOptions> = {},
  ): Promise<GeneratedFrame | null> {
    try {
      const finalOptions = { ...this.DEFAULT_OPTIONS, ...options };

      // Generate random rotation if not specified
      if (finalOptions.rotation === 0) {
        finalOptions.rotation = (Math.random() - 0.5) * 16; // ±8 degrees
      }

      // Check if frame already exists in cache
      const cacheKey = this.generateCacheKey(playerName, finalOptions);
      const cachedFrame = await this.getCachedFrame(cacheKey, playerName);

      if (cachedFrame) {
        return cachedFrame;
      }

      // Ensure font is registered
      await this.ensureFontRegistered();

      // Get player image
      const playerImage = await findPlayerImage(playerName);
      const imageUrl = playerImage?.url || getFallbackImage();
      const source = playerImage?.source || "fallback";

      // Generate the frame
      const frameBuffer = await this.createPolaroidFrame(
        imageUrl,
        playerName,
        finalOptions,
      );

      // Save to cache
      const savedFrame = await this.saveFrameToCache(
        cacheKey,
        frameBuffer,
        playerName,
        finalOptions,
        source,
      );

      return savedFrame;
    } catch (error) {
      console.error("Error generating player frame:", error);
      return null;
    }
  }

  /**
   * Create the actual polaroid frame with image and text
   */
  private static async createPolaroidFrame(
    imageUrl: string,
    playerName: string,
    options: FrameOptions,
  ): Promise<Buffer> {
    try {
      // Load the source image
      let imageBuffer: Buffer;

      if (imageUrl.startsWith("http")) {
        const response = await fetch(imageUrl);
        if (!response.ok) throw new Error("Failed to fetch image");
        imageBuffer = Buffer.from(await response.arrayBuffer());
      } else {
        // Local fallback image
        imageBuffer = await fs.readFile(
          path.join(process.cwd(), "public", imageUrl),
        );
      }

      // Get image metadata
      const imageMetadata = await sharp(imageBuffer).metadata();
      const originalWidth = imageMetadata.width!;
      const originalHeight = imageMetadata.height!;

      // Calculate final frame dimensions
      const { frameWidth, frameHeight, imageWidth, imageHeight } =
        this.calculateDimensions(originalWidth, originalHeight, options);

      // Resize the image to fit within the content area
      const resizedImageBuffer = await sharp(imageBuffer)
        .resize(imageWidth, imageHeight, {
          fit: "cover",
          position: "center",
        })
        .jpeg({ quality: 90 })
        .toBuffer();

      // Create canvas for the frame
      const canvas = createCanvas(frameWidth, frameHeight);
      const ctx = canvas.getContext("2d");

      // Fill with white background (polaroid frame)
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, frameWidth, frameHeight);

      // Add subtle shadow/depth to the frame
      ctx.shadowColor = "rgba(0, 0, 0, 0.1)";
      ctx.shadowBlur = 2;
      ctx.shadowOffsetX = 1;
      ctx.shadowOffsetY = 1;

      // Load and draw the resized image
      const resizedImage = await loadImage(resizedImageBuffer);
      const imageX = (frameWidth - imageWidth) / 2;
      const imageY =
        (frameHeight -
          imageHeight -
          this.getBottomSpaceHeight(frameHeight, options)) /
        2;

      ctx.drawImage(resizedImage, imageX, imageY, imageWidth, imageHeight);

      // Reset shadow for text
      ctx.shadowColor = "transparent";

      // Add handwritten player name
      await this.addHandwrittenText(
        ctx,
        playerName,
        frameWidth,
        frameHeight,
        options,
      );

      // Convert canvas to buffer
      return canvas.toBuffer("image/jpeg", { quality: 0.9 });
    } catch (error) {
      console.error("Error creating polaroid frame:", error);
      throw error;
    }
  }

  /**
   * Add handwritten text to the frame
   */
  private static async addHandwrittenText(
    ctx: CanvasRenderingContext2D,
    playerName: string,
    frameWidth: number,
    frameHeight: number,
    options: FrameOptions,
  ): Promise<void> {
    // Set font properties
    ctx.font = `${options.textOptions.fontSize}px "${options.textOptions.fontFamily}"`;
    ctx.fillStyle = options.textOptions.color;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // Add slight rotation for handwritten effect
    const textRotation = (Math.random() - 0.5) * 0.1; // ±3 degrees

    // Calculate text position
    const bottomSpaceHeight = this.getBottomSpaceHeight(frameHeight, options);
    const textY = frameHeight - bottomSpaceHeight / 2;

    // Position variations based on style
    let textX = frameWidth / 2;
    if (options.textOptions.position === "bottom-left") {
      textX = frameWidth * 0.25;
      ctx.textAlign = "left";
    } else if (options.textOptions.position === "bottom-right") {
      textX = frameWidth * 0.75;
      ctx.textAlign = "right";
    }

    // Apply rotation and draw text
    ctx.save();
    ctx.translate(textX, textY);
    ctx.rotate(textRotation);

    // Add text shadow for depth
    ctx.shadowColor = "rgba(0, 0, 0, 0.1)";
    ctx.shadowBlur = 1;
    ctx.shadowOffsetX = 0.5;
    ctx.shadowOffsetY = 0.5;

    ctx.fillText(playerName, 0, 0);
    ctx.restore();
  }

  /**
   * Calculate frame and image dimensions
   */
  private static calculateDimensions(
    originalWidth: number,
    originalHeight: number,
    options: FrameOptions,
  ): {
    frameWidth: number;
    frameHeight: number;
    imageWidth: number;
    imageHeight: number;
  } {
    // For polaroid style, maintain aspect ratio but fit within max constraints
    if (options.style === "polaroid") {
      const aspectRatio = originalWidth / originalHeight;

      let targetWidth = Math.min(originalWidth, options.maxWidth);
      let targetHeight = targetWidth / aspectRatio;

      if (targetHeight > options.maxHeight) {
        targetHeight = options.maxHeight;
        targetWidth = targetHeight * aspectRatio;
      }

      // Calculate frame dimensions with borders
      const borderLeft = targetWidth * (options.borderPercent.left / 100);
      const borderRight = targetWidth * (options.borderPercent.right / 100);
      const borderTop = targetHeight * (options.borderPercent.top / 100);
      const borderBottom = targetHeight * (options.borderPercent.bottom / 100);

      const frameWidth = targetWidth + borderLeft + borderRight;
      const frameHeight = targetHeight + borderTop + borderBottom;

      return {
        frameWidth: Math.round(frameWidth),
        frameHeight: Math.round(frameHeight),
        imageWidth: Math.round(targetWidth),
        imageHeight: Math.round(targetHeight),
      };
    } else {
      // Trading card style - fixed dimensions
      const frameWidth = options.maxWidth;
      const frameHeight = options.maxHeight;

      // Calculate image area within frame
      const borderLeft = frameWidth * (options.borderPercent.left / 100);
      const borderRight = frameWidth * (options.borderPercent.right / 100);
      const borderTop = frameHeight * (options.borderPercent.top / 100);
      const borderBottom = frameHeight * (options.borderPercent.bottom / 100);

      const imageWidth = frameWidth - borderLeft - borderRight;
      const imageHeight = frameHeight - borderTop - borderBottom;

      return {
        frameWidth,
        frameHeight,
        imageWidth: Math.round(imageWidth),
        imageHeight: Math.round(imageHeight),
      };
    }
  }

  /**
   * Get the height of the bottom space for text
   */
  private static getBottomSpaceHeight(
    frameHeight: number,
    options: FrameOptions,
  ): number {
    return frameHeight * (options.borderPercent.bottom / 100);
  }

  /**
   * Ensure the Diary-Notes font is registered
   */
  private static async ensureFontRegistered(): Promise<void> {
    if (this.fontRegistered) return;

    try {
      await fs.access(this.FONT_PATH);
      registerFont(this.FONT_PATH, { family: "Diary-Notes" });
      this.fontRegistered = true;
    } catch (error) {
      console.warn("Diary-Notes font not found, using fallback font");
      // Fallback to a system font
      this.DEFAULT_OPTIONS.textOptions.fontFamily = "Comic Sans MS, cursive";
    }
  }

  /**
   * Generate cache key for frame
   */
  private static generateCacheKey(
    playerName: string,
    options: FrameOptions,
  ): string {
    const optionsHash = Buffer.from(JSON.stringify(options))
      .toString("base64")
      .slice(0, 8);
    const nameHash = playerName.toLowerCase().replace(/[^a-z0-9]/g, "-");
    return `${nameHash}-${optionsHash}`;
  }

  /**
   * Check if frame exists in cache
   */
  private static async getCachedFrame(
    cacheKey: string,
    playerName: string,
  ): Promise<GeneratedFrame | null> {
    try {
      await fs.access(this.CACHE_DIR);
    } catch {
      await fs.mkdir(this.CACHE_DIR, { recursive: true });
      return null;
    }

    const framePath = path.join(this.CACHE_DIR, `${cacheKey}.jpg`);

    try {
      await fs.access(framePath);

      // Get frame dimensions
      const metadata = await sharp(framePath).metadata();

      return {
        url: `/generated-frames/${cacheKey}.jpg`,
        localPath: framePath,
        width: metadata.width!,
        height: metadata.height!,
        playerName,
        cached: true,
        source: "wikipedia", // We don't store this info, assume wikipedia
      };
    } catch {
      return null;
    }
  }

  /**
   * Save generated frame to cache
   */
  private static async saveFrameToCache(
    cacheKey: string,
    frameBuffer: Buffer,
    playerName: string,
    options: FrameOptions,
    source: "wikipedia" | "fallback",
  ): Promise<GeneratedFrame> {
    // Ensure cache directory exists
    await fs.mkdir(this.CACHE_DIR, { recursive: true });

    const framePath = path.join(this.CACHE_DIR, `${cacheKey}.jpg`);
    await fs.writeFile(framePath, frameBuffer);

    // Get dimensions
    const metadata = await sharp(frameBuffer).metadata();

    return {
      url: `/generated-frames/${cacheKey}.jpg`,
      localPath: framePath,
      width: metadata.width!,
      height: metadata.height!,
      playerName,
      cached: false,
      source,
    };
  }

  /**
   * Clean up old cached frames
   */
  static async cleanupCache(
    maxAge: number = 7 * 24 * 60 * 60 * 1000,
  ): Promise<number> {
    try {
      const files = await fs.readdir(this.CACHE_DIR);
      let deletedCount = 0;

      for (const file of files) {
        if (!file.endsWith(".jpg")) continue;

        const filePath = path.join(this.CACHE_DIR, file);
        const stats = await fs.stat(filePath);

        if (Date.now() - stats.mtime.getTime() > maxAge) {
          await fs.unlink(filePath);
          deletedCount++;
        }
      }

      return deletedCount;
    } catch (error) {
      console.error("Error cleaning up cache:", error);
      return 0;
    }
  }

  /**
   * Get cache statistics
   */
  static async getCacheStats(): Promise<{
    totalFrames: number;
    totalSize: number;
    oldestFrame: Date | null;
    newestFrame: Date | null;
  }> {
    try {
      const files = await fs.readdir(this.CACHE_DIR);
      const jpgFiles = files.filter((f) => f.endsWith(".jpg"));

      let totalSize = 0;
      let oldestTime = Date.now();
      let newestTime = 0;

      for (const file of jpgFiles) {
        const filePath = path.join(this.CACHE_DIR, file);
        const stats = await fs.stat(filePath);
        totalSize += stats.size;
        oldestTime = Math.min(oldestTime, stats.mtime.getTime());
        newestTime = Math.max(newestTime, stats.mtime.getTime());
      }

      return {
        totalFrames: jpgFiles.length,
        totalSize,
        oldestFrame: jpgFiles.length > 0 ? new Date(oldestTime) : null,
        newestFrame: jpgFiles.length > 0 ? new Date(newestTime) : null,
      };
    } catch (error) {
      console.error("Error getting cache stats:", error);
      return {
        totalFrames: 0,
        totalSize: 0,
        oldestFrame: null,
        newestFrame: null,
      };
    }
  }
}

// Export convenience functions
export const generatePlayerFrame = (
  playerName: string,
  options?: Partial<FrameOptions>,
) => PolaroidFrameGenerator.generatePlayerFrame(playerName, options);

export const cleanupFrameCache = (maxAge?: number) =>
  PolaroidFrameGenerator.cleanupCache(maxAge);

export const getFrameCacheStats = () => PolaroidFrameGenerator.getCacheStats();
